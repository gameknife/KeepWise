# KeepWise Tauri 迁移技术选型决策表（v2 已定版）

更新时间：2026-02-23
状态：关键方向已拍板（进入 Phase 0 / Phase 1 执行）
关联文档：`docs/engineering/TAURI_STACK_MIGRATION_MASTER_PLAN.md`

## 1. 文档目的

本文件用于为 Tauri 技术栈迁移提供“可执行的选型决策依据”，覆盖：

- 前端框架与工程化方案
- Rust 数据访问与迁移执行
- Tauri 命令层与前后端契约管理
- 导入链路迁移策略（含过渡期桥接）
- 测试、CI/CD、发布工程化方案

目标不是一次决定所有细节，而是优先拍板会影响架构方向的核心项，减少返工。

## 2. 选型原则（本项目约束下）

按优先级排序：

1. **口径稳定优先**：财务计算与导入结果一致性高于“新潮技术”。
2. **跨平台可落地优先**：桌面可行但移动端不可行的方案只能作为临时过渡。
3. **渐进迁移优先**：允许阶段性桥接，但必须有明确退役路径。
4. **工程复杂度可控**：单人/小团队可维护比“理论最优”更重要。
5. **自动化友好**：便于做差分测试、构建矩阵、回归流水线。

## 3. 需要拍板的关键决策（摘要）

| 决策项 | 候选 | 当前推荐 | 状态 | 备注 |
| --- | --- | --- | --- | --- |
| 前端框架 | React / Vue / Solid | **React** | 已确认 | 生态最稳，组件与图表方案成熟 |
| 前端构建 | Vite / Rsbuild | **Vite** | 已确认 | 与 Tauri 集成成熟、心智负担低（随 React 方案确认） |
| Rust SQLite 方案 | `rusqlite` / `sqlx(sqlite)` | **rusqlite** | 已确认 | 本地单机场景更直接，迁移成本低 |
| DB Migration 执行 | 复用 `.sql` / ORM 迁移 | **复用现有 SQL** | 推荐 | 保持单一 schema 来源 |
| 前后端 DTO 管理 | 手写 TS 类型 / 自动生成 | **阶段化：先手写冻结，后自动生成** | 已确认 | 先稳口径，再提升效率 |
| 前端数据层 | 纯 hooks / React Query + store | **TanStack Query + 轻量本地状态** | 推荐 | API 缓存与异步态更清晰 |
| 图表库 | ECharts / Chart.js / uPlot | **ECharts（优先复用）** | 推荐 | 现有图表需求复杂度适配好 |
| 导入迁移策略 | 直接全 Rust / 分阶段桥接 | **分阶段桥接（桌面临时）** | 已确认 | 移动端最终必须 Rust |
| PDF 导入方案 | 立即 Rust 化 / 后置攻坚 | **后置攻坚（Rust 实现）** | 已确认 | 桌面首发必须可用；移动端首发可选（可先不含） |
| 移动端首发节奏 | iOS+Android 同步 / 先 Android | **先 Android** | 已确认 | iOS 后续跟进 |
| E2E 测试 | Playwright / 手工为主 | **Playwright（桌面）+ 手工补充移动端** | 推荐 | 先保核心流程自动化 |
| CI/CD | GitHub Actions / 本地脚本 | **GitHub Actions + 本地脚本并行** | 推荐 | CI 做验证，本地脚本做开发效率 |

## 4. 详细决策矩阵

## 4.1 前端框架（Tauri WebView UI）

评估维度（建议权重）：

- 组件生态与图表生态（30%）
- 开发效率与可维护性（25%）
- 团队/社区资料可得性（20%）
- Tauri 集成成熟度（15%）
- 性能与包体（10%）

### 候选对比

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **React + TypeScript** | 生态最成熟；图表/表格/表单方案多；容易找到迁移实践 | 需要约束状态管理与组件规范，否则容易散 | **推荐** |
| Vue + TypeScript | 上手快，模板表达清晰；组件组织友好 | 团队后续维护与生态选择面略窄（相较 React） | 可选备选 |
| Solid + TypeScript | 性能优秀；响应式模型简洁 | 生态与实践样本相对少；迁移期踩坑成本高 | 不建议作为首选 |

### 推荐结论

- **推荐：React + TypeScript + Vite**
- 原因：
  - 本项目后续需要较强的表格、图表、表单、状态管理、测试工具链；
  - Tauri 官方/社区示例、问题排查资料更丰富；
  - 单人/小团队长期维护成本更可控。

### PoC 验证项（必须）

- 在 Tauri 桌面壳内完成一个页面：
  - 表单输入（记录录入）
  - 图表展示（财富曲线）
  - 表格分页/筛选（基础查询）
- 验证打包体积、冷启动、页面切换流畅度

## 4.2 前端构建工具（Vite / Rsbuild）

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **Vite** | Tauri 常用组合；配置简单；开发体验成熟 | 大型工程需要自律组织目录与构建配置 | **推荐** |
| Rsbuild | 构建性能好；现代化配置体验 | 与 Tauri 迁移实战样例相对少 | 暂不优先 |

推荐：

- **Vite**（Phase 0 直接落地，不拖延）

## 4.3 Rust SQLite 访问方案（`rusqlite` vs `sqlx`）

评估维度：

- 与现有 SQL 迁移兼容性
- 本地单机应用复杂度匹配
- 调试成本与出错可控性
- 跨平台构建复杂度

### 候选对比

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **`rusqlite`** | 贴近 SQLite 原生；简单直接；适合本地单机；复用 SQL 容易 | 编译期 SQL 校验弱；需要自己维护映射代码 | **推荐（首选）** |
| `sqlx`（sqlite） | 类型化与查询抽象更工程化；测试支持好 | 宏/异步心智复杂度更高；本地场景收益不一定覆盖复杂度 | 可选备选 |

### 推荐结论

- **推荐：`rusqlite` + 明确 Repository/Query 层边界**
- 适用原因：
  - 当前已存在成熟 SQL 与 SQLite 资产；
  - 本地单机应用并发压力有限；
  - 迁移初期重点是“口径一致”和“快速替换”，不是 ORM 化。

### 风险控制

- 为复杂查询建立集成测试与黄金样本
- SQL 字符串集中管理（避免散落 command 层）

## 4.4 数据库迁移执行策略（Schema Source of Truth）

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **继续复用 `db/migrations/*.sql`** | 避免双份 schema；兼容现有 Python 体系；切换风险低 | 需自己写 Rust 迁移执行器与版本记录逻辑 | **推荐** |
| 重写为 Rust ORM 迁移（如 sea-orm/diesel） | 统一在 Rust 生态内管理 | 高返工风险；会引入第二套 schema 描述 | 不建议当前阶段 |

推荐：

- **以现有 SQL 迁移文件为单一事实来源**
- Rust 侧只负责执行、记录、健康检查与幂等控制

## 4.5 Tauri 命令层与前后端契约管理

这是迁移成败的关键项之一，因为前端重构和 Rust 重写会并行推进。

### 候选策略

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| 手写 TS 类型（按接口文档维护） | 初始最快；便于先冻结契约 | 后期容易漂移，需要纪律约束 | **Phase 1 推荐** |
| Rust -> TS 自动生成 DTO（代码生成） | 一致性更好；减少重复维护 | 引入工具链学习与兼容问题 | **Phase 2+ 推荐** |
| 完全依赖运行时 JSON（无类型） | 速度快 | 高风险；回归排查困难 | 不建议 |

### 推荐结论（阶段化）

- **Phase 1：先手写契约与 TS 类型，建立黄金样本与差分测试**
- **Phase 2+：引入 DTO 自动生成/同步机制（再选具体库）**

原因：

- 当前首要目标是冻结口径与输出，不是先引入复杂生成工具；
- 先有稳定 DTO，再上生成工具，失败成本更低。

### 实施建议

- 建立 `frontend/src/types/contracts.ts`
- 建立 `docs/engineering/` 下接口契约文档（样例 + 字段语义）
- 对关键 command 返回值做前端运行时校验（可选 `zod`，用于边界防御）

## 4.6 前端状态管理与数据获取层

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **TanStack Query + 局部 state（React state/Zustand）** | 异步请求缓存、重试、失效管理成熟；适合数据型工作台 | 需要规范 query key 与缓存失效策略 | **推荐** |
| 仅 React state + 自写 hooks | 依赖少 | 随页面复杂度上升容易变乱 | 不建议作为长期方案 |
| Redux Toolkit 全局化 | 规范强、生态成熟 | 对当前项目可能偏重，样板较多 | 非首选 |

推荐：

- **TanStack Query 负责服务端/命令数据**
- **本地 UI 状态使用 React state（必要时补充 Zustand）**

说明：

- 不建议一开始引入过重全局状态；
- 数据型页面的缓存与失效逻辑交给 Query 更稳。

## 4.7 图表方案（财富曲线/收益曲线/消费分析）

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **ECharts** | 功能全面；折线/柱状/标签/缩放/图例成熟；中文资料多 | 包体偏大；需做组件封装与性能约束 | **推荐（优先复用）** |
| Chart.js | 轻量、简单场景快 | 复杂交互与定制能力相对弱 | 可用于简图，不作主方案 |
| uPlot | 高性能折线优秀 | 功能覆盖面不如 ECharts；开发心智成本高 | 非首选 |

推荐：

- **继续使用 ECharts（前提是做统一封装组件）**
- 统一图表配置与主题，避免在页面中散落 option 拼装逻辑

## 4.8 Rust 并发/执行模型（命令、数据库、重计算）

需要避免一开始陷入“全异步化重构”。

### 推荐策略

- **命令层可以异步，但领域/数据库逻辑优先保持同步可测试**
- 对耗时任务使用 `spawn_blocking` 或专门后台任务封装
- 先建立正确性，再做性能并发优化

理由：

- 本地单机财务工具的瓶颈通常不是高并发；
- 过早引入复杂 async/锁模型会显著增加调试难度。

状态：

- **推荐（架构策略）**

## 4.9 导入链路迁移策略（是否允许 Python 桥接）

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **分阶段桥接（桌面临时）+ Rust 最终收口** | 能快速启动 Tauri 化；避免被高风险导入阻塞 | 会存在双栈维护窗口；需要清晰退役时间点 | **推荐** |
| 一次性全部 Rust 重写后再切 Tauri | 架构更纯 | 周期长、风险集中、验证慢 | 不建议 |
| 长期保留 Python sidecar | 开发快 | 移动端不可用；发布复杂；长期维护差 | 不建议作为终态 |

推荐结论：

- **允许桌面端短期 Python 桥接，但必须写入里程碑和退役条件**
- 移动端路径不允许依赖 Python bridge

## 4.10 导入解析子项选型（CSV/XLSX/EML/PDF）

本项建议用“分项 PoC + 分阶段定案”，不要一次拍死所有库。

### 已可直接拍板项（低风险）

| 子项 | 推荐 | 说明 |
| --- | --- | --- |
| CSV 导入 | Rust 原生（`csv` 类库路线） | 低风险，优先迁移 |
| XLSX 导入 | Rust 原生（如 `calamine` 路线） | 较成熟，适合早期迁移 |

### 需 PoC 后拍板项（中高风险）

| 子项 | 候选策略 | 当前建议 | 备注 |
| --- | --- | --- | --- |
| EML 解析 | Rust MIME/邮件解析库 vs 临时桥接 | **先 PoC Rust 原生** | 若可行，尽早原生化 |
| 招行 PDF 解析 | Rust PDF 方案 vs 桌面桥接 | **后置攻坚 + 桌面过渡桥接** | 风险最高，避免阻塞主线 |

PoC 验证标准（导入类统一）：

- 金额、日期、商户、摘要提取准确率满足当前基线
- 异常样本错误提示可读
- 脱敏样本差分测试通过

## 4.11 测试栈（单元/集成/差分/E2E）

| 层级 | 推荐方案 | 原因 | 状态 |
| --- | --- | --- | --- |
| Rust 单元测试 | `cargo test` | 核心算法与纯函数验证基础 | 推荐 |
| Rust 集成测试 | `cargo test --test ...` + 临时 SQLite | 验证 DB + 服务层口径 | 推荐 |
| 跨语言差分测试 | 复用 Python 编排脚本（初期） | 最快落地，复用现有基线能力 | 推荐 |
| 前端单测 | `vitest` | 与 Vite 配套，速度快 | 推荐 |
| 前端组件/E2E | `Playwright`（桌面优先） | 核心流程自动化价值高 | 推荐 |
| 移动端自动化 | 暂以手工 + 冒烟脚本 | 初期成本高，后续按需要引入 Appium/Detox | 阶段性策略 |

推荐重点：

- 差分测试优先级高于 UI 自动化数量
- 先把财务口径锁住，再扩大前端自动化覆盖面

## 4.12 CI/CD 与发布工程化

| 方案 | 优点 | 风险/代价 | 结论 |
| --- | --- | --- | --- |
| **GitHub Actions 为主 + 本地脚本补充** | 标准化、可审计、易做矩阵构建 | 初期配置稍多 | **推荐** |
| 完全本地脚本 | 起步快 | 不可追踪、团队协作弱、平台矩阵难保证 | 不建议作为主方案 |

推荐结构：

- 本地脚本：开发便捷（回归、差分、单平台构建）
- CI：PR 验证与 RC 构建矩阵
- 发布签名：保留人工关口（安全要求）

## 5. 推荐技术栈基线（供 Phase 0 启动）

这是一份“先跑起来”的基线，不代表后续不能调整，但调整必须有收益证明。

### 5.1 推荐基线（v1）

- **Tauri**：v2
- **Frontend**：React + TypeScript + Vite
- **前端数据层**：TanStack Query + React state（必要时 Zustand）
- **图表**：ECharts（统一封装组件）
- **Rust DB**：`rusqlite`
- **DB Migration**：继续执行 `db/migrations/*.sql`
- **Rust 架构**：`commands -> services -> repositories`
- **契约管理**：Phase 1 手写冻结，Phase 2+ 再引入自动生成
- **测试**：
  - Rust：`cargo test`
  - Frontend：Vitest + Playwright
  - 口径：Python vs Rust 差分测试
- **CI/CD**：GitHub Actions（桌面构建矩阵优先）

### 5.2 过渡策略（明确限制）

- 桌面端允许临时 Python bridge（导入链路部分）
- 移动端不允许依赖 Python bridge
- 招行 PDF 导入的 Rust 重写可延后至主路径稳定后攻坚
- 桌面首发版本必须包含招行 PDF 导入能力（必要时通过临时 bridge 保证）
- 移动端首发优先 Android，iOS 后续跟进
- 移动端首发可不包含招行 PDF 导入（后续补齐）

## 6. 必做 PoC 清单（用于拍板）

以下 PoC 结果将决定是否维持上述推荐：

## P0-A：Tauri + React + Rust command 最小闭环

目标：

- 一个页面调用一个 Rust command
- 读写 SQLite（或至少 DB ping）
- 显示结果与错误态

通过标准：

- 桌面端 2 平台可运行（建议 macOS + Windows）

## P0-B：Rust DB 层复用现有迁移 SQL

目标：

- Rust 启动时执行 `db/migrations/*.sql`
- 幂等运行验证
- 可读取现有库基本表结构

通过标准：

- 空库初始化成功
- 重复执行不破坏数据

## P0-C：投资收益率（Modified Dietz）Rust 差分样例

目标：

- Rust 实现最小收益率计算链路
- 对比 Python 基线样本输出

通过标准：

- 误差在预设阈值内

## P0-D：导入链路可行性 PoC（CSV/XLSX/EML）

目标：

- 至少完成一类导入（建议先 CSV/XLSX）Rust 原型
- EML 做可行性验证（库选型）

通过标准：

- 样本提取结果可用，错误信息可读

## P0-E：Tauri 移动端空壳启动验证

目标：

- iOS/Android 至少一个平台完成启动
- 验证基础权限与目录访问方式

通过标准：

- 能启动并调用一个本地命令

## 7. 决策冻结顺序（建议）

按影响面排序，建议按以下顺序拍板：

1. 前端框架 + 构建工具（React + Vite）
2. Rust DB 方案（`rusqlite`）+ SQL 迁移复用策略
3. 契约管理策略（Phase 1 手写冻结，Phase 2 自动生成）
4. 前端数据层（TanStack Query）
5. 导入迁移过渡策略（允许桌面桥接）
6. 测试栈与 CI/CD 基线
7. 导入解析具体库（EML/PDF 以 PoC 结果决定）

原因：

- 前 4 项决定工程骨架；
- 后 3 项可以在骨架稳定后逐步细化。

## 8. 已确认的拍板结果（2026-02-23）

以下决策已由项目负责人确认，可作为 Phase 0 / Phase 1 执行基线：

1. 接受 `React + TypeScript + Vite` 作为默认前端方案。
2. 接受 `rusqlite` 作为迁移前中期 Rust SQLite 主方案。
3. 接受过渡策略：桌面端可临时 Python bridge，移动端不允许依赖。
4. 招行 PDF 导入首发要求：
   - 桌面版：必须进入首发版本。
   - 移动版：可选，可在后续版本补齐。
5. 移动端首发节奏：先 Android，iOS 后续跟进。
6. 同意先做契约冻结/差分测试，再进行大规模前端重构。

### 8.1 对执行计划的直接影响

- Phase 0/1 可以立即按 `React + Vite + rusqlite` 启动，不再等待框架争论。
- Phase 1 必须优先产出契约冻结与差分测试框架（高于前端视觉重构）。
- Phase 5 的“PDF Rust 重写”可以后置，但桌面首发路径必须通过（允许临时 bridge）。
- 移动端里程碑与 CI 优先覆盖 Android，iOS 作为后续里程碑推进。

## 9. 后续文档拆分建议（可选）

本决策表确定后，建议继续拆出：

- `TAURI_P0_POC_PLAN.md`（PoC 任务与验收）
- `TAURI_CONTRACT_FREEZE_PLAN.md`（契约冻结与黄金样本）
- `TAURI_DIFF_TEST_STRATEGY.md`（跨语言差分测试方案）
- `TAURI_APP_STRUCTURE_DRAFT.md`（目录结构与模块边界）

---

注：本文件重点是“方向拍板”，不是最终实现细节。实现细节应在阶段子计划与 ADR（Architecture Decision Record）中落地。
